基于您提供的图片信息和组件化要求，我将为您设计一个高度模块化的Vue3实现方案。以下是按照功能划分的组件设计方案：

### 组件化设计（5个核心组件）

1. ​**​FilterBar (筛选栏组件)​**​
   
   - 功能：顶部筛选区域
   - 包含元素：
     - 日期范围显示（2025/05/29 - 2025/07/28）
     - 网站类别下拉筛选
     - 时间格式选择
     - 数据合并复选框
     - 批量删除按钮
   - Props：`dateRange`, `categories`
   - Emits：`filter-change`, `bulk-delete`

2. ​**​DataTable (数据表格组件)​**​
   
   - 功能：主体数据展    示
   - 包含元素：
     - 表格头部（日期、域名等标题）
     - 数据行
     - 操作按钮组
   - Props：`tableData`, `columns`
   - Emits：`row-action`

3. ​**​TableRow (表格行组件)​**​
   
   - 功能：单行数据显示
   - 包含元素：
     - 日期单元格
     - 域名单元格（带特殊样式）
     - 网站名称单元格
     - 类别单元格
     - 浏览时长（带格式转换）
     - 访问次数
     - 操作按钮组
   - Props：`rowData`
   - Slots：`custom-cell`（用于自定义单元格）

4. ​**​ActionButton (操作按钮组件)​**​
   
   - 功能：复用型操作按钮
   - 包含元素：
     - 分析按钮（黄色）
     - 删除按钮（红色）
     - 白名单按钮（绿色）
   - Props：`type`(analyze/delete/whitelist), `isActive`(白名单状态)
   - Emits：`click`

5. ​**​PaginationBar (分页组件)​**​
   
   - 功能：分页控制
   - 包含元素：
     - 数据总量显示（共19条）
     - 每页条数选择
     - 页码输入框
     - 前往按钮
     - 版本号（v3.5.5）
   - Props：`currentPage`, `pageSize`, `totalItems`
   - Emits：`page-change`

### 组件关系结构

```
<RootContainer>
  ├── <FilterBar>
  ├── <DataTable>
  │    ├── <TableHeader>
  │    └── <TableRow> * N
  │         └── <ActionButton> * 3
  └── <PaginationBar>
```

### 伪代码实现

```
// 1. FilterBar组件
const FilterBar = defineComponent({
  props: ['dateRange', 'categories'],
  emits: ['filter-change', 'bulk-delete'],
  setup(props, { emit }) {
    // 处理筛选变化
    const handleCategoryChange = (e) => {
      emit('filter-change', { type: 'category', value: e.target.value })
    }

    return () => (
      <div class="filter-bar">
        <div class="date-range">{props.dateRange}</div>
        <select onChange={handleCategoryChange}>
          {props.categories.map(cat => 
            <option value={cat}>{cat}</option>
          )}
        </select>
        <button onClick={() => emit('bulk-delete')}>
          <i class="fas fa-trash"></i> 批量删除
        </button>
      </div>
    )
  }
})

// 2. ActionButton组件（高度可复用）
const ActionButton = defineComponent({
  props: {
    type: { type: String, required: true },
    isActive: Boolean
  },
  emits: ['click'],
  setup(props, { emit }) {
    const buttonConfig = {
      analyze: { icon: 'chart-line', text: '分析', color: 'warning' },
      delete: { icon: 'trash', text: '删除', color: 'danger' },
      whitelist: { 
        icon: 'plus', 
        text: props.isActive ? '白名单' : '+白名单',
        color: 'success' 
      }
    }

    const config = buttonConfig[props.type]

    return () => (
      <button 
        class={`btn btn-${config.color}`}
        onClick={() => emit('click')}
      >
        <i class={`fas fa-${config.icon}`}></i>
        {config.text}
      </button>
    )
  }
})

// 3. TableRow组件
const TableRow = defineComponent({
  props: ['rowData'],
  setup(props) {
    // 格式化浏览时长
    const formatDuration = (dur) => dur.replace('m', '分').replace('s', '秒')

    return () => (
      <tr>
        <td>{props.rowData.date}</td>
        <td class="domain-cell">{props.rowData.domain}</td>
        <td>{props.rowData.name}</td>
        <td>{props.rowData.category}</td>
        <td>{formatDuration(props.rowData.duration)}</td>
        <td>{props.rowData.visits}</td>
        <td class="action-cell">
          <ActionButton type="analyze" />
          <ActionButton type="delete" />
          <ActionButton 
            type="whitelist" 
            isActive={props.rowData.whitelisted} 
          />
        </td>
      </tr>
    )
  }
})

// 4. DataTable组件
const DataTable = defineComponent({
  props: ['tableData', 'columns'],
  setup(props) {
    return () => (
      <table class="data-table">
        <thead>...</thead>
        <tbody>
          {props.tableData.map(row => 
            <TableRow rowData={row} key={row.id} />
          )}
        </tbody>
      </table>
    )
  }
})

// 5. PaginationBar组件
const PaginationBar = defineComponent({
  props: ['currentPage', 'pageSize', 'totalItems'],
  emits: ['page-change'],
  setup(props, { emit }) {
    const handlePageChange = (newPage) => {
      if(newPage >= 1 && newPage <= totalPages) {
        emit('page-change', newPage)
      }
    }

    return () => (
      <div class="pagination-bar">
        <span>共{props.totalItems}条数据</span>
        <div class="page-controls">
          <select>...</select>
          <button onClick={() => handlePageChange(props.currentPage - 1)}>
            <i class="fas fa-angle-left"></i>
          </button>
          <input v-model={currentPageInput} />
          <button onClick={() => handlePageChange(props.currentPage + 1)}>
            <i class="fas fa-angle-right"></i>
          </button>
        </div>
        <div class="version">v3.5.5</div>
      </div>
    )
  }
})
```

### 组件化优势

1. ​**​高复用性​**​：
   
   - ActionButton组件可多次复用于不同场景
   - TableRow组件统一处理数据行展示逻辑

2. ​**​职责分离​**​：
   
   - 筛选逻辑 → FilterBar
   - 数据显示 → DataTable + TableRow
   - 用户操作 → ActionButton
   - 分页控制 → PaginationBar

3. ​**​数据流清晰​**​：
   
   ```
   graph TD
   A[根组件] -->|传递数据| B(FilterBar)
   A -->|传递数据| C(DataTable)
   A -->|传递数据| D(PaginationBar)
   B -->|事件通知| A[根组件]
   C -->|事件通知| A
   D -->|事件通知| A
   ```

4. ​**​可维护性​**​：
   
   - 添加新功能只需修改对应组件
   - 样式修改隔离在组件内部

5. ​**​扩展性​**​：
   
   - 可轻松添加"数据导出"、"多选"等新功能组件
   - 支持插件式添加额外筛选条件

### 实现建议

1. 使用Pinia管理全局状态：
   
   ```
   // store/websiteData.js
   export const useWebsiteStore = defineStore('website', {
    state: () => ({
      rawData: [],
      filters: {
        dateRange: '2025/05/29 - 2025/07/28',
        category: 'all'
      },
      pagination: {
        currentPage: 1,
        pageSize: 20
      }
    }),
    getters: {
      filteredData(state) {
        // 实现筛选逻辑
      }
    },
    actions: {
      deleteItem(id) {...},
      toggleWhitelist(id) {...}
    }
   })
   ```

2. 采用Composition API组织逻辑：
   
   ```
   // 在组件中使用
   setup() {
    const store = useWebsiteStore()
    const filteredData = computed(() => store.filteredData)
   
    const handleDelete = (id) => store.deleteItem(id)
   
    return { filteredData, handleDelete }
   }
   ```

这样的组件化设计完全符合您图片中的界面要求，同时保证了代码的可维护性和可扩展性，每个组件都保持单一职责原则，数据流清晰明确。
